# -*- coding: utf-8 -*-
"""2022 CCF394 - classificação de digitos com SVM e MLP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1F20KbvmzsGHDcNIELzRgzh_JSZ0ugAAx

#Classificação de digitos manuscritos com SVM
###material adaptado de:
https://scikit-learn.org/stable/auto_examples/classification/plot_digits_classification.html

###Um bom tutorial:
https://towardsdatascience.com/support-vector-machine-mnist-digit-classification-with-python-including-my-hand-written-digits-83d6eca7004a
![](https://miro.medium.com/max/584/1*2lSjt9YKJn9sxK7DSeGDyw.jpeg)
"""

import matplotlib.pyplot as plt
# Importa datasets, classificadores e metricas
from sklearn import datasets, svm, metrics
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay

#carrega dataset de digitos.
digits = datasets.load_digits()

# os digitos são uma matriz de 8x8 .
# os numeros de 0 a 3 podem ser vistos abaixo

_, axes = plt.subplots(2, 4)
images_and_labels = list(zip(digits.images, digits.target))
for ax, (image, label) in zip(axes[0, :], images_and_labels[:4]):
    ax.set_axis_off()
    ax.imshow(image, cmap=plt.cm.gray_r, interpolation='nearest')
    ax.set_title('Treinando: %i' % label)

# alterando o shape da imagem para ficar na forma de vetor.
n_samples = len(digits.images)
data = digits.images.reshape((n_samples, -1))

"""![](https://scikit-learn.org/stable/_images/sphx_glr_plot_iris_svc_001.png)


"""

# Criando o classificador
#https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html
classifier = svm.SVC(gamma=0.001)

# dividindo dados para treinamento 50%...
X_train, X_test, y_train, y_test = train_test_split(
    data, digits.target, test_size=0.5, shuffle=False)

# Treinando
classifier.fit(X_train, y_train)

# Realizando a predição
predicted = classifier.predict(X_test)

images_and_predictions = list(zip(digits.images[n_samples // 2:], predicted))
for ax, (image, prediction) in zip(axes[1, :], images_and_predictions[:4]):
    ax.set_axis_off()
    ax.imshow(image, cmap=plt.cm.gray_r, interpolation='nearest')
    ax.set_title('Predição: %i' % prediction)


cm = confusion_matrix(y_test, predicted, labels=classifier.classes_)
disp = ConfusionMatrixDisplay(confusion_matrix=cm,
                              display_labels=classifier.classes_)
disp.plot()
plt.xlabel('Valor real label')
plt.ylabel('saida SVM (previsão)');

plt.show()



#disp = metrics.plot_confusion_matrix(classifier, X_test, y_test)
#disp.figure_.suptitle("Matriz de Confusão")
#print("Matriz de confusão:\n%s" % disp.confusion_matrix)
#plt.show()
from sklearn.metrics import accuracy_score
print("Precisão da SVM : ",accuracy_score(y_test, predicted)*100)

"""###agora , com redes neurais..

"""

# Importando Bibliotecas:
import matplotlib.pyplot as plt
from sklearn.datasets import fetch_openml
from sklearn.neural_network import MLPClassifier
import time
import timeit
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn import datasets
import numpy as np
import matplotlib.pyplot as plt

from sklearn import svm, datasets
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix
from sklearn.utils.multiclass import unique_labels

from sklearn.metrics import accuracy_score

classifier = MLPClassifier(hidden_layer_sizes=(30,30), max_iter=300,activation = 'relu',solver='adam',random_state=1)
classifier=classifier.fit(X_train, y_train)
#Using the trained network to predict

#Predicting y for X_val
y_pred = classifier.predict(X_test)
print("Precisão da rede MPL : ",accuracy_score(y_test, y_pred)*100)
#print(cm)

import seaborn as sns
from sklearn.metrics import confusion_matrix
mat = confusion_matrix(y_pred, y_test)
sns.heatmap(mat.T, square=True, annot=True, fmt='d', cbar=False)
plt.xlabel('Valor real label')
plt.ylabel('saida rede (previsão)');
plt.show()
